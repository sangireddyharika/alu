This GitHub repository contains the Verilog implementation of an 8-bit Arithmetic Logic Unit (ALU), developed as part of an academic project at Dayananda Sagar College of Engineering, Bangalore. The ALU is capable of performing a wide range of arithmetic and logical operations through individual Verilog modules, each activated using enable signals and coordinated using a finite state machine (FSM). The supported operations include addition (via a carry lookahead adder), subtraction, multiplication (Booth multiplier), division, increment, and decrement. It also includes logic functions like AND, OR, NOT, NAND, NOR, XOR, and XNOR, along with bitwise shift operations such as left and right shifts. Inputs are provided in a 16-bit format specifying the instruction, register selection, and operand, which are processed through states T0, T1, and T2 of the FSM. The system architecture includes control signals like `IRin`, `GIN`, and various module-specific enables to guide data flow and execution. The ALU’s functionality is verified through a comprehensive testbench and waveform simulations, demonstrating accurate results for each instruction. Applications of this ALU span across embedded systems, digital signal processing, cryptography, real-time control systems, and processor design, making it a fundamental building block for both academic and industry use cases.

This 8-bit ALU project demonstrates a modular and scalable digital design using Verilog HDL, ideal for both academic exploration and practical hardware applications. Each instruction in the ALU is mapped to a dedicated submodule, promoting clear structure and ease of debugging. The FSM-driven control unit ensures proper sequencing of operations, with states T0, T1, and T2 managing instruction fetch, decode, and execution phases, respectively. The ALU accepts input in a custom 16-bit binary format where the instruction, register select (R0 or R1), and operand data are clearly defined. Operations are initiated using control signals such as `IRin` (Instruction Register enable) and `run`, and the result is stored in an output register `G`.

For arithmetic computations, advanced techniques like carry lookahead addition and Booth multiplication are utilized to ensure speed and efficiency. Logical operations follow standard gate-level implementations, with each gate module including enable-controlled logic for conditional execution. Bitwise shift operations (left and right) are designed to preserve data integrity while simulating register-level shifts. The ALU has been synthesized and simulated using tools like ModelSim, with waveform outputs validating correct functionality under various test cases.

This design also highlights practical digital design principles such as modular coding, FSM-based control, reusability, and ease of integration into larger systems like processors and embedded controllers. With potential applications in Digital Signal Processing (DSP), cryptography, AI/ML hardware, and real-time control systems, this 8-bit ALU serves as a foundational element for learners and developers aiming to master hardware description languages and digital architecture design.

In addition to its core functionality, the 8-bit ALU project emphasizes **instruction-level modularity and clarity**, enabling easy expansion or modification of operations. Each logic or arithmetic unit—such as AND, OR, XOR, NOT, or the Booth multiplier—is encapsulated in its own Verilog module. These modules are activated selectively through control signals, ensuring that only the desired operation is performed at any given clock cycle. This method not only improves power efficiency in real hardware applications but also simplifies testing and debugging by isolating behaviors.

The control flow of the ALU is governed by a **finite state machine (FSM)** that transitions through three primary states (T0, T1, T2), corresponding to the fetch, decode, and execute stages of instruction handling. For instance, in T0, the instruction register (`IR`) is loaded with the 16-bit instruction using the `IRin` signal. In T1 and T2, the operands are routed through the selected data path and the required ALU module is activated. The result is then stored in a temporary register (`G`), and a `done` signal is asserted to indicate completion of the operation.

The design also includes **specialized instructions** like increment, decrement, left shift, and right shift, which are often overlooked in basic ALU models. These are essential for compiler support and microprocessor control flow and are executed using simple arithmetic or bitwise logic. Shift operations maintain the logical integrity of input data by zero-padding either the most or least significant bits, emulating register-level behavior found in real CPUs.

This ALU is ideal not just for simulation but also for **synthesis on FPGAs**, offering an educational platform to understand RTL design, data flow, control sequencing, and logic optimization. Moreover, this project reinforces real-world design practices such as hierarchical coding, control enable schemes, FSM synchronization, and result validation through waveform analysis. As such, it serves as an excellent stepping stone for students and hobbyists preparing to build custom processors or develop hardware accelerators for specialized computing tasks.

